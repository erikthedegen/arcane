<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Definitely not Urban Rivals</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        /* Improved CSS styles for better UI/UX */

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
        }

        /* Title styles */
        .title-container {
            background: white;
            padding: 20px 40px;
            margin-bottom: 50px;
            border-top: 4px solid black;
            border-bottom: 4px solid black;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .main-title {
            font-family: 'Bangers', cursive;
            font-size: 48px;
            margin: 0;
            color: #333;
            text-align: center;
        }

        .subtitle {
            font-family: 'Bangers', cursive;
            font-size: 32px;
            margin: 20px 0;
            color: #555;
            text-align: center;
        }

        /* Button container */
        .button-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            flex-grow: 1;
            justify-content: center;
        }

        /* Fancy button styles */
        .button-wrapper {
            position: relative;
            display: inline-block;
        }

        .custom-button {
            padding: 12px 24px;
            font-size: 18px;
            background-color: #F0F0F0;
            color: #000000;
            border: none;
            transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1.5);
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            cursor: pointer;
        }

        .button-shadow {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            background-color: #000000;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .button-wrapper:hover .button-shadow {
            opacity: 1;
        }

        .custom-button.clicked {
            transform: translate(0, 0) scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        /* Deck selection styles */
        .deck-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .deck-button {
            padding: 15px 30px;
            font-size: 16px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Deck Builder Styles */
        #deck-builder {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }

        .era-section {
            margin-bottom: 30px;
        }

        .era-title {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .card-pool {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card-select {
            border: 1px solid #333;
            padding: 5px;
            margin: 5px;
            width: 120px;
            cursor: pointer;
            position: relative;
            transition: transform 0.3s;
            background-color: #fff;
        }

        .card-select:hover {
            transform: scale(1.05);
        }

        .card-select.selected {
            border-color: gold;
            box-shadow: 0 0 10px gold;
        }

        .deck-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }

        .deck-button:hover {
            border-color: #999;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        /* Game Board */
        .game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            position: relative;
        }

        .player-area {
            width: 100%;
            margin: 20px 0;
            position: relative;
        }

        .player-area.current-turn {
            border: 2px solid gold;
            animation: turnIndicator 1s infinite alternate;
        }

        @keyframes turnIndicator {
            from {
                box-shadow: 0 0 10px gold;
            }
            to {
                box-shadow: 0 0 20px gold;
            }
        }

        .player-header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .player-header .player-name {
            font-size: 24px;
            margin-right: 10px;
        }

        .player-header .player-stats {
            display: flex;
            font-size: 14px;
            position: relative;
        }

        .player-header .player-stats p {
            margin: 0 5px;
        }

        .card-row {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
        }

        .card {
            border: 1px solid #333;
            padding: 5px;
            margin: 5px;
            width: 120px;
            cursor: pointer;
            position: relative;
            transition: transform 0.3s;
            background-color: #fff;
        }

        .card.used {
            opacity: 0.5;
            pointer-events: none;
        }

        .card .marker {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }

        .era-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: #f0f0f0;
            border: 1px solid #333;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .card .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            font-size: 12px;
            text-align: center;
        }

        .card:hover {
            transform: scale(1.05);
        }

        .highlight {
            border-color: gold;
            animation: highlightAnim 0.5s infinite alternate;
        }

        @keyframes highlightAnim {
            from {
                box-shadow: 0 0 5px gold;
            }
            to {
                box-shadow: 0 0 15px gold;
            }
        }

        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .stats {
            font-size: 12px;
            margin-top: 5px;
            text-align: left;
        }

        /* Bucks Selection */
        #bucks-selection {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        #bucks-slider {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 10px;
            width: 100%;
            max-width: 600px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .bucks-icons-container {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .buck-icon {
            width: 32px;
            height: 32px;
            margin-right: -12px;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.2s;
        }

        .buck-icon.unfilled {
            opacity: 0.3;
        }

        .buck-icon:last-child {
            margin-right: 0;
        }

        .control-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 10px;
        }

        .control-button:hover {
            background: #3a3a3a;
        }

        .bottom-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 20px;
        }

        .back-arrow {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attack-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .attack-label {
            color: white;
            font-size: 16px;
            text-transform: uppercase;
        }

        .attack-value {
            background: #2a2a2a;
            color: #4DA6FF;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
        }

        .fight-button {
            background: #FFD700;
            color: #8A2BE2;
            padding: 8px 24px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
        }

        .fight-button:hover {
            background: #FFE44D;
        }

        /* Battle Result Display */
        .battle-result {
            font-size: 48px;
            margin: 20px 0;
            opacity: 0;
            animation: battleResultAnim 2s forwards;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            text-align: center;
            font-weight: bold;
            text-shadow: 2px 2px 5px #000;
        }

        @keyframes battleResultAnim {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-50%);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) translateY(-50%);
            }
            100% {
                opacity: 0;
                transform: scale(1) translateY(-50%);
            }
        }

        /* Turn Indicator */
        .turn-indicator {
            font-size: 36px;
            font-weight: bold;
            opacity: 0;
            position: absolute;
            top: 45%;
            width: 100%;
            text-align: center;
            animation: fadeInOut 2s forwards;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }
            25% {
                opacity: 1;
            }
            75% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        /* LP Animation */
        .lp-animation {
            position: absolute;
            color: red;
            font-weight: bold;
            font-size: 18px;
            animation: lpChangeAnim 2s forwards;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes lpChangeAnim {
            0% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
        }

        /* Modal and Notification styles */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 1000;
        }

        .modal input[type="text"] {
            padding: 5px;
            font-size: 16px;
            margin-bottom: 10px;
            width: 80%;
        }

        .modal button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }

        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 1000;
        }

        .notification p {
            margin-bottom: 20px;
        }

        .notification button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        /* Hide elements by default */
        #main-menu,
        #deck-builder,
        #play-interface {
            display: none;
        }

        /* Main Menu Styles */
        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        #main-menu h2.subtitle {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        /* Deck List Styles */
        #decks-ul {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            width: 100%;
        }

        #decks-ul li {
            margin-bottom: 10px;
            text-align: center;
        }

        .deck-builder-title {
            font-family: 'Bangers', cursive;
            font-size: 48px;
            margin: 0;
            color: #333;
            text-align: center;
        }
        /* Loading Banner */
.loading-banner {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.95);
    padding: 10px 20px;
    border: 2px solid #333;
    border-radius: 10px;
    z-index: 1000;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}


    </style>
</head>
<body>

    <!-- Login Area -->
    <div id="login-area">
        <div class="title-container">
            <h1 class="main-title">Definitely not Urban Rivals</h1>
        </div>
        <div class="button-container">
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="selectPlayer('senf')">senf</button>
            </div>
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="selectPlayer('börek')">börek</button>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu" style="display: none;">
        <h2 class="subtitle">Main Menu</h2>
        <div class="menu-buttons">
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="goToPlay()">Play</button>
            </div>
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="goToDeckBuilder()">Deck Builder</button>
            </div>
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="logout()">Logout</button>
            </div>
        </div>
    </div>

    <!-- Deck Builder -->
    <div id="deck-builder" style="display: none;">
        <div id="deck-list">
            <h2 class="deck-builder-title">Deck Builder</h2>
            <h3>Your Decks</h3>
            <ul id="decks-ul">
                <!-- Decks will be listed here -->
            </ul>
            <div class="deck-actions">
                <div class="button-wrapper">
                    <div class="button-shadow"></div>
                    <button class="custom-button" onclick="createNewDeck()">Create New Deck</button>
                </div>
                <div class="button-wrapper">
                    <div class="button-shadow"></div>
                    <button class="custom-button" onclick="backToMenu()">Back to Menu</button>
                </div>
            </div>
        </div>

        <div id="deck-editor" style="display: none;">
            <h3 id="deck-editor-title">Create New Deck</h3>
            <div id="card-pool">
                <!-- Card pool will be displayed here -->
            </div>
            <div class="deck-actions">
                <p>Selected Cards: <span id="selected-count">0</span>/8</p>
                <div class="button-wrapper">
                    <div class="button-shadow"></div>
                    <button class="custom-button" onclick="saveDeck()">Save Deck</button>
                </div>
                <div class="button-wrapper">
                    <div class="button-shadow"></div>
                    <button class="custom-button" onclick="cancelDeckEditing()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Play Interface -->
    <div id="play-interface" style="display: none;">
        <h2 class="subtitle">Select a Deck to Play</h2>
        <div class="deck-selection">
            <ul id="play-decks-ul">
                <!-- Decks will be listed here dynamically -->
            </ul>
            <div class="button-wrapper">
                <div class="button-shadow"></div>
                <button class="custom-button" onclick="backToMenu()">Back to Menu</button>
            </div>
        </div>
    </div>

    <!-- Game Board -->
    <div class="game-board" id="game-board" style="display: none;">
        <!-- Player areas will be injected here -->
    </div>

    <!-- Action Area for Bucks Selection -->
    <div id="action-area">
        <div id="bucks-selection" style="display: none;">
            <div class="bucks-slider" id="bucks-slider"></div>
        </div>
    </div>

    <!-- Notification Modal -->
    <div id="notification" class="notification" style="display: none;">
        <p id="notification-message"></p>
        <button onclick="closeNotification()">OK</button>
    </div>

    <!-- Modal for Deck Name Input -->
    <div id="deck-name-modal" class="modal" style="display: none;">
        <p>Enter Deck Name:</p>
        <input type="text" id="deck-name-input" placeholder="Deck Name">
        <br>
        <button onclick="confirmSaveDeck()">Save</button>
        <button onclick="closeDeckNameModal()">Cancel</button>
    </div>

    <!-- Include Socket.io -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Button hover effects
        document.querySelectorAll('.button-wrapper').forEach(container => {
            const button = container.querySelector('.custom-button');
            const moveDistance = 8;
            let isClicked = false;

            container.addEventListener('mouseenter', (e) => {
                if (isClicked) return;

                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const width = rect.width;
                const height = rect.height;

                const isLeft = x < width / 2;
                const isTop = y < height / 2;

                let moveX = isLeft ? moveDistance : -moveDistance;
                let moveY = isTop ? moveDistance : -moveDistance;

                button.style.transform = `translate(${moveX}px, ${moveY}px)`;
                button.style.boxShadow = `${-moveX}px ${-moveY}px 16px rgba(0, 0, 0, 0.15)`;
            });

            container.addEventListener('mouseleave', () => {
                if (!isClicked) {
                    button.style.transform = 'translate(0, 0)';
                    button.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                }
            });

            button.addEventListener('mousedown', () => {
                isClicked = true;
                button.classList.add('clicked');
                button.style.transform = 'translate(0, 0)';
                button.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
            });

            button.addEventListener('mouseup', () => {
                button.classList.remove('clicked');
            });
        });

        // Client Code

        // Game State Variables
        let playerId;
        let playerName;
        let opponentName;
        let myPlayer;
        let opponentPlayer;
        let gameState;
        let gameOver = false;
        let lastBattleResultId = null;

        // Deck Builder Variables
        let allCards = [];
        let selectedCards = [];
        let decks = [];
        let editingDeckId = null;

        // Initialize Socket.io
        const socket = io();

        // Handle socket connection
        socket.on('connect', () => {
            playerId = socket.id;
            console.log('Connected with socket.id:', playerId);
        });

        // Handle receiving player data after joining
        socket.on('playerData', (data) => {
            console.log('Received playerData:', data);
            playerName = data.playerName;
            showMainMenu();
        });

        // Handle game full scenario
        socket.on('gameFull', () => {
            showNotification("The game is full. Please try again later.");
        });

        // Handle opponent disconnection
        socket.on('playerDisconnected', (message) => {
            showNotification(message);
            setTimeout(() => {
                location.reload();
            }, 3000); // Reload after 3 seconds
        });

        // Handle match found
        socket.on('matchFound', (data) => {
    console.log('Match found:', data);
    hideLoading();
    // Waiting for game to start
});


        // Handle game start
        socket.on('gameStarted', (state) => {
            gameState = state;
            initializeGame();
        });

        // Handle game state updates
        socket.on('gameState', (state) => {
            gameState = state;
            updateGame();
        });

        // Handle errors from the server
        socket.on('error', (message) => {
            showNotification(message);
        });

        // Function to handle player selection (senf or börek)
        function selectPlayer(choice) {
            playerName = choice;
            socket.emit('joinGame', playerName);
            document.getElementById('login-area').style.display = 'none';
            console.log(`Player selected: ${choice}`);
        }

        // Show Main Menu
        function showMainMenu() {
            document.getElementById('main-menu').style.display = 'flex';
        }

        // Go to Deck Builder
        function goToDeckBuilder() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('deck-builder').style.display = 'flex';
            loadDecks();
        }

        // Go to Play Interface
        function goToPlay() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('play-interface').style.display = 'flex';
            loadPlayDecks();
        }

        // Logout
        function logout() {
            location.reload();
        }

        // Back to Main Menu
        function backToMenu() {
            document.getElementById('deck-builder').style.display = 'none';
            document.getElementById('play-interface').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        }

        // Load Decks from Server
        async function loadDecks() {
            try {
                const response = await fetch(`/api/decks?user=${encodeURIComponent(playerName)}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch decks');
                }
                decks = await response.json();
                renderDeckList();
            } catch (error) {
                showNotification('Error loading decks: ' + error.message);
            }
        }

        function renderDeckList() {
            const decksUl = document.getElementById('decks-ul');
            decksUl.innerHTML = '';
            decks.forEach(deck => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.className = 'deck-button';
                button.innerText = deck.name;
                button.onclick = () => editDeck(deck.id);
                li.appendChild(button);
                decksUl.appendChild(li);
            });
        }

        // Create New Deck
        async function createNewDeck() {
            selectedCards = [];
            editingDeckId = null;
            document.getElementById('deck-list').style.display = 'none';
            document.getElementById('deck-editor-title').innerText = 'Create New Deck';
            document.getElementById('deck-editor').style.display = 'flex';
            await loadAllCards();
            renderCardPool();
            updateSelectedCount();
        }

        // Edit Existing Deck
        async function editDeck(deckId) {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) {
                showNotification('Deck not found.');
                return;
            }
            selectedCards = deck.cards.slice(); // Copy the array
            editingDeckId = deckId;
            document.getElementById('deck-list').style.display = 'none';
            document.getElementById('deck-editor-title').innerText = `Edit Deck: ${deck.name}`;
            document.getElementById('deck-editor').style.display = 'flex';
            await loadAllCards();
            renderCardPool();
            updateSelectedCount();
        }

        // Cancel Deck Editing
        function cancelDeckEditing() {
            selectedCards = [];
            editingDeckId = null;
            document.getElementById('deck-editor').style.display = 'none';
            document.getElementById('deck-list').style.display = 'flex';
        }

        // Load All Cards
        async function loadAllCards() {
            if (allCards.length > 0) return; // Already loaded
            try {
                const response = await fetch('/api/cards');
                if (!response.ok) {
                    throw new Error('Failed to fetch cards');
                }
                allCards = await response.json();
            } catch (error) {
                showNotification('Error loading cards: ' + error.message);
            }
        }

        // Render Card Pool
  function renderCardPool() {
    const cardPoolDiv = document.getElementById('card-pool');
    cardPoolDiv.innerHTML = '';

    const eras = {};
    allCards.forEach(card => {
      if (!eras[card.era]) {
        eras[card.era] = [];
      }
      eras[card.era].push(card);
    });

    for (const era in eras) {
      const eraSection = document.createElement('div');
      eraSection.className = 'era-section';

      const eraTitle = document.createElement('h3');
      eraTitle.className = 'era-title';
      eraTitle.innerText = era;
      eraSection.appendChild(eraTitle);

      const cardPool = document.createElement('div');
      cardPool.className = 'card-pool';

      eras[era].forEach(card => {
        const cardDiv = createCardSelectDiv(card);
        cardPool.appendChild(cardDiv);
      });

      eraSection.appendChild(cardPool);
      cardPoolDiv.appendChild(eraSection);
    }
  }

        // Create Card Select Div for Deck Builder
  function createCardSelectDiv(card) {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'card-select';
    cardDiv.dataset.name = card.name;

    // Era Badge
    const eraBadge = document.createElement('div');
    eraBadge.className = 'era-badge';
    let eraText = '';
    switch (card.era) {
      case 'Era 1':
        eraText = 'I';
        break;
      case 'Era 2':
        eraText = 'II';
        break;
      case 'Era 3':
        eraText = 'III';
        break;
      case 'Era 4':
        eraText = 'IV';
        break;
      case 'Era 5':
        eraText = 'V';
        break;
      case 'Era 6':
        eraText = 'VI';
        break;
      case 'Era 7':
        eraText = 'VII';
        break;
      case 'Era 8':
        eraText = 'VIII';
        break;
      default:
        eraText = '?';
    }
    eraBadge.textContent = eraText;
    cardDiv.appendChild(eraBadge);

    // Card Image
    const img = document.createElement('img');
    img.src = card.image;
    img.alt = card.name;
    img.width = 100;
    img.height = 100;
    cardDiv.appendChild(img);

    // Card Name
    const nameElem = document.createElement('div');
    nameElem.innerHTML = `<strong>${card.name}</strong>`;
    cardDiv.appendChild(nameElem);

    // Card Stats
    const statsDiv = document.createElement('div');
    statsDiv.className = 'stats';
    statsDiv.innerHTML = `
      Strength: ${card.strength}<br>
      Damage: ${card.damage}<br>
      Ability: ${card.abilityDesc}
    `;
    cardDiv.appendChild(statsDiv);

    // Highlight if selected
    if (selectedCards.includes(card.name)) {
      cardDiv.classList.add('selected');
    }

    // Click handler
    cardDiv.onclick = () => toggleCardSelection(card.name, cardDiv);

    return cardDiv;
  }

        // Toggle Card Selection
        function toggleCardSelection(cardName, cardDiv) {
            if (selectedCards.includes(cardName)) {
                selectedCards = selectedCards.filter(name => name !== cardName);
                cardDiv.classList.remove('selected');
            } else {
                if (selectedCards.length >= 8) {
                    showNotification('You can select up to 8 cards.');
                    return;
                }
                selectedCards.push(cardName);
                cardDiv.classList.add('selected');
            }
            updateSelectedCount();
        }

        // Update Selected Count
        function updateSelectedCount() {
            document.getElementById('selected-count').innerText = selectedCards.length;
        }

        // Save Deck
        function saveDeck() {
            if (selectedCards.length !== 8) {
                showNotification('You must select exactly 8 cards.');
                return;
            }
            document.getElementById('deck-name-modal').style.display = 'flex';
        }

        // Confirm Save Deck
        async function confirmSaveDeck() {
            const deckName = document.getElementById('deck-name-input').value.trim();
            if (!deckName) {
                showNotification('Please enter a deck name.');
                return;
            }

            const deckData = {
                user: playerName,
                deckName,
                cards: selectedCards,
                deckId: editingDeckId,
            };

            try {
                const response = await fetch('/api/decks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(deckData),
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to save deck');
                }
                showNotification(result.message);
                closeDeckNameModal();
                cancelDeckEditing();
                loadDecks();
            } catch (error) {
                showNotification('Error saving deck: ' + error.message);
            }
        }

        // Close Deck Name Modal
        function closeDeckNameModal() {
            document.getElementById('deck-name-modal').style.display = 'none';
            document.getElementById('deck-name-input').value = '';
        }

        // Load Decks for Play
        async function loadPlayDecks() {
            try {
                const response = await fetch(`/api/decks?user=${encodeURIComponent(playerName)}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch decks');
                }
                decks = await response.json();
                renderPlayDecks();
            } catch (error) {
                showNotification('Error loading decks: ' + error.message);
            }
        }

        function renderPlayDecks() {
            const playDecksUl = document.getElementById('play-decks-ul');
            playDecksUl.innerHTML = '';
            decks.forEach(deck => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.className = 'deck-button';
                button.innerText = deck.name;
                button.onclick = () => selectDeckForPlay(deck.id);
                li.appendChild(button);
                playDecksUl.appendChild(li);
            });
        }

        // Select Deck for Play
        function selectDeckForPlay(deckId) {
    const selectedDeck = decks.find(d => d.id === deckId);
    if (!selectedDeck) {
        showNotification('Deck not found.');
        return;
    }
    // Start matchmaking
    socket.emit('findMatch', { user: playerName, deckId });
    showLoading('Finding a match...');
}


        function showLoading(message) {
    const loadingBanner = document.getElementById('loading-banner');
    if (!loadingBanner) {
        const banner = document.createElement('div');
        banner.id = 'loading-banner';
        banner.className = 'loading-banner';
        banner.innerText = message || 'Loading...';
        document.body.appendChild(banner);
    } else {
        loadingBanner.innerText = message || 'Loading...';
        loadingBanner.style.display = 'block';
    }
}

function hideLoading() {
    const loadingBanner = document.getElementById('loading-banner');
    if (loadingBanner) {
        loadingBanner.style.display = 'none';
    }
}


        // Initialize the game UI after both players have joined
        function initializeGame() {
            hideLoading();
            // Hide other interfaces and show game board
            document.getElementById('game-board').style.display = 'flex';
            document.getElementById('login-area').style.display = 'none';
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('deck-builder').style.display = 'none';
            document.getElementById('play-interface').style.display = 'none';

            // Update local references to players
            if (playerId === gameState.player1.id) {
                myPlayer = gameState.player1;
                opponentPlayer = gameState.player2;
            } else {
                myPlayer = gameState.player2;
                opponentPlayer = gameState.player1;
            }

            renderPlayerAreas();
            updateGame();
        }

        // Render player areas (both players' fields)
        function renderPlayerAreas() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = ''; // Clear any existing content

            // Create opponent's area
            const opponentArea = createPlayerArea(opponentPlayer, false);
            gameBoard.appendChild(opponentArea);

            // Battle result placeholder
            const battleResultDiv = document.createElement('div');
            battleResultDiv.id = 'battle-result';
            battleResultDiv.className = 'battle-result';
            gameBoard.appendChild(battleResultDiv);

            // Create my area
            const myArea = createPlayerArea(myPlayer, true);
            gameBoard.appendChild(myArea);
        }

        // Create a player area (either mine or opponent's)
        function createPlayerArea(player, isMyArea) {
            const playerArea = document.createElement('div');
            playerArea.className = 'player-area';
            playerArea.id = isMyArea ? 'my-player-area' : 'opponent-player-area';

            const playerHeader = document.createElement('div');
            playerHeader.className = 'player-header';

            const playerNameElem = document.createElement('h2');
            playerNameElem.className = 'player-name';
            playerNameElem.id = `player${player === gameState.player1 ? '1' : '2'}-name`;
            playerNameElem.innerText = player.name;
            playerHeader.appendChild(playerNameElem);

            const playerStats = document.createElement('div');
            playerStats.className = 'player-stats';

            const lpElem = document.createElement('p');
            lpElem.innerHTML = `<strong>LP:</strong> <span id="player${player === gameState.player1 ? '1' : '2'}-lp">${player.lp}</span>`;
            playerStats.appendChild(lpElem);

            const bucksElem = document.createElement('p');
            bucksElem.innerHTML = `<strong>Bucks:</strong> <span id="player${player === gameState.player1 ? '1' : '2'}-bucks">${player.bucks}</span>`;
            playerStats.appendChild(bucksElem);

            playerHeader.appendChild(playerStats);
            playerArea.appendChild(playerHeader);

            const cardRow = document.createElement('div');
            cardRow.className = 'card-row';
            cardRow.id = `player${player === gameState.player1 ? '1' : '2'}-cards`;
            playerArea.appendChild(cardRow);

            return playerArea;
        }

        // Update the game UI based on the current game state
        function updateGame() {
            // Update local references to players
            if (playerId === gameState.player1.id) {
                myPlayer = gameState.player1;
                opponentPlayer = gameState.player2;
            } else {
                myPlayer = gameState.player2;
                opponentPlayer = gameState.player1;
            }

            // Update UI elements
            updateGameInfo();
            renderField();

            // Handle turn logic
            if (gameState.currentPlayer.id === playerId && !gameOver) {
                if (myPlayer.selectedCard === null) {
                    enableCardSelection();
                    displayTurnIndicator("Your Turn");
                } else if (document.getElementById('bucks-selection').style.display !== 'block') {
                    showBucksSelection();
                }
            } else {
                displayTurnIndicator(`${gameState.currentPlayer.name}'s Turn`);
            }

            // Handle battle result display
            if (gameState.battleResult && gameState.battleResult.id !== lastBattleResultId) {
                handleBattleResult(gameState.battleResult);
                lastBattleResultId = gameState.battleResult.id;
            }

            // Check for game over
            if (gameState.gameOver && !gameOver) {
                gameOver = true;
                const winner = determineWinner();
                displayGameOver(winner);
                console.log(`Game Over. ${winner.name} wins!`);
                displayTurnIndicator(`${winner.name} Wins!`);
            }
        }

        // Enable card selection for the current player
        function enableCardSelection() {
            renderField();
        }

        // Render the field for both players
        function renderField() {
            const myCardsDiv = document.getElementById(`player${myPlayer === gameState.player1 ? '1' : '2'}-cards`);
            const opponentCardsDiv = document.getElementById(`player${opponentPlayer === gameState.player1 ? '1' : '2'}-cards`);
            myCardsDiv.innerHTML = '';
            opponentCardsDiv.innerHTML = '';

            // Render my cards
            myPlayer.field.forEach((card, index) => {
                const cardDiv = createCardDiv(card, index, myPlayer, true);
                myCardsDiv.appendChild(cardDiv);
            });

            // Render opponent's cards
            opponentPlayer.field.forEach((card, index) => {
                const cardDiv = createCardDiv(card, index, opponentPlayer, false);
                opponentCardsDiv.appendChild(cardDiv);
            });

            // Highlight current player's area
            document.getElementById('my-player-area').classList.toggle('current-turn', gameState.currentPlayer.id === myPlayer.id);
            document.getElementById('opponent-player-area').classList.toggle('current-turn', gameState.currentPlayer.id === opponentPlayer.id);
        }

        // Create a card element
        function createCardDiv(card, index, player) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            cardDiv.dataset.index = index;

            // Era Badge
    const eraBadge = document.createElement('div');
    eraBadge.className = 'era-badge';
    let eraText = '';
    switch (card.era) {
      case 'Era 1':
        eraText = 'I';
        break;
      case 'Era 2':
        eraText = 'II';
        break;
      case 'Era 3':
        eraText = 'III';
        break;
      case 'Era 4':
        eraText = 'IV';
        break;
      case 'Era 5':
        eraText = 'V';
        break;
      case 'Era 6':
        eraText = 'VI';
        break;
      case 'Era 7':
        eraText = 'VII';
        break;
      case 'Era 8':
        eraText = 'VIII';
        break;
      default:
        eraText = '?';
    }
    eraBadge.textContent = eraText;
    cardDiv.appendChild(eraBadge);

    // Card Image
    const img = document.createElement('img');
    img.src = card.image;
    img.alt = card.name;
    img.width = 100;
    img.height = 100;
    cardDiv.appendChild(img);

    // Card Name
    const nameElem = document.createElement('div');
    nameElem.innerHTML = `<strong>${card.name}</strong>`;
    cardDiv.appendChild(nameElem);

    // Card Stats
    const statsDiv = document.createElement('div');
    statsDiv.className = 'stats';
    statsDiv.innerHTML = `
      Strength: ${card.strength}<br>
      Damage: ${card.damage}<br>
      Ability: ${card.abilityDesc}
    `;
    cardDiv.appendChild(statsDiv);

    // Highlight selected card
    if (player.selectedCard === index) {
      cardDiv.classList.add('highlight');
    } else {
      cardDiv.classList.remove('highlight');
    }

    // Handle used cards
    if (card.used) {
      cardDiv.classList.add('used');
      cardDiv.style.opacity = '0.5';

      // Add marker for win/loss
      const marker = document.createElement('div');
      marker.className = 'marker';
      marker.style.backgroundColor = card.wonBattle ? 'green' : 'red';
      cardDiv.appendChild(marker);

      // Add overlay with battle details
      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.innerHTML = `
        Bucks Bet: ${card.bucksBet}<br>
        Total Attack: ${card.totalStrength}
      `;
      cardDiv.appendChild(overlay);
    }

    // Disable click on used cards
    if (card.used || player.id !== playerId || gameState.currentPlayer.id !== playerId || player.selectedCard !== null) {
      cardDiv.classList.add('disabled');
    } else {
      cardDiv.onclick = () => selectCard(index);
    }

    return cardDiv;
  }

        // Handle card selection
        function selectCard(index) {
            socket.emit('playerAction', {
                action: 'selectCard',
                selectedCard: index,
            });
        }

        // Show the bucks selection slider
        function showBucksSelection() {
            const bucksSelection = document.getElementById('bucks-selection');
            bucksSelection.style.display = 'flex';

            // Create the bucks slider
            createBucksSlider();

            // Add event listener to allow clicking outside to cancel
            setTimeout(() => { // Timeout to prevent immediate trigger when opening
                document.addEventListener('click', outsideClickListener);
            }, 0);
        }

        // Create the bucks slider with clickable rectangles
        function createBucksSlider() {
            const slider = document.getElementById('bucks-slider');
            slider.innerHTML = '';
            const totalBucks = myPlayer.bucks;

            // Create main container
            const sliderControls = document.createElement('div');
            sliderControls.className = 'slider-controls';

            // Minus button
            const minusBtn = document.createElement('button');
            minusBtn.className = 'control-button';
            minusBtn.innerHTML = '−';
            minusBtn.onclick = () => adjustBucks(-1);
            sliderControls.appendChild(minusBtn);

            // Icons container
            const iconsContainer = document.createElement('div');
            iconsContainer.className = 'bucks-icons-container';

            // Create buck icons
            for (let i = 0; i <= totalBucks; i++) {
                const icon = document.createElement('img');
                icon.src = 'bucksicon.png'; // Make sure this image exists in your assets
                icon.className = 'buck-icon';
                if (i > 0) {
                    icon.classList.add('unfilled');
                }
                icon.dataset.value = i;
                icon.onclick = () => setSliderValue(i);
                icon.onmouseenter = (e) => handleMouseEnter(e, i);
                iconsContainer.appendChild(icon);
            }
            sliderControls.appendChild(iconsContainer);

            // Plus button
            const plusBtn = document.createElement('button');
            plusBtn.className = 'control-button';
            plusBtn.innerHTML = '+';
            plusBtn.onclick = () => adjustBucks(1);
            sliderControls.appendChild(plusBtn);

            slider.appendChild(sliderControls);

            // Bottom controls container
            const bottomControls = document.createElement('div');
            bottomControls.className = 'bottom-controls';

            // Back arrow (left side)
            const backArrow = document.createElement('button');
            backArrow.className = 'back-arrow';
            backArrow.innerHTML = '←';
            backArrow.onclick = () => {
                document.getElementById('bucks-selection').style.display = 'none';
                myPlayer.selectedCard = null;
                myPlayer.selectedBucks = 0;
                socket.emit('playerAction', { action: 'cancelSelection' });
            };

            // Attack display
            const attackDisplay = document.createElement('div');
            attackDisplay.className = 'attack-display';

            const attackLabel = document.createElement('span');
            attackLabel.className = 'attack-label';
            attackLabel.textContent = 'ATTACK';

            const attackValue = document.createElement('div');
            attackValue.className = 'attack-value';
            attackValue.id = 'attack-value';
            // Set initial attack value based on base strength
            const selectedCard = myPlayer.field[myPlayer.selectedCard];
            const baseStrength = selectedCard.baseStrength || selectedCard.strength;
            attackValue.textContent = baseStrength;

            attackDisplay.appendChild(attackLabel);
            attackDisplay.appendChild(attackValue);

            // Fight button
            const fightBtn = document.createElement('button');
            fightBtn.className = 'fight-button';
            fightBtn.textContent = 'FIGHT';
            fightBtn.onclick = submitMove;

            // Add all elements to bottom controls
            bottomControls.appendChild(backArrow);
            bottomControls.appendChild(attackDisplay);
            bottomControls.appendChild(fightBtn);

            slider.appendChild(bottomControls);

            // Add mouse drag functionality
            let isMouseDown = false;
            iconsContainer.addEventListener('mousedown', () => isMouseDown = true);
            document.addEventListener('mouseup', () => isMouseDown = false);
            document.addEventListener('mouseleave', () => isMouseDown = false);

            // Initialize with no bucks selected
            setSliderValue(0);
        }

        function calculateAttackValue(selectedBucks) {
            const selectedCard = myPlayer.field[myPlayer.selectedCard];
            const baseStrength = selectedCard.baseStrength || selectedCard.strength;
            return baseStrength * (1 + selectedBucks);
        }

        function handleMouseEnter(event, value) {
            if (event.buttons === 1) { // Left mouse button is being held
                setSliderValue(value);
            }
        }

        function adjustBucks(change) {
            const currentValue = myPlayer.selectedBucks || 0;
            const newValue = Math.max(0, Math.min(myPlayer.bucks, currentValue + change));
            setSliderValue(newValue);
        }

        function setSliderValue(value) {
            const icons = document.querySelectorAll('.buck-icon');
            icons.forEach((icon, index) => {
                if (index <= value) {
                    icon.classList.remove('unfilled');
                } else {
                    icon.classList.add('unfilled');
                }
            });

            myPlayer.selectedBucks = value;
            const attackValue = calculateAttackValue(value);
            document.getElementById('attack-value').textContent = attackValue;
        }

        // Submit the selected move with the chosen bucks
        function submitMove() {
            const bucks = myPlayer.selectedBucks;
            if (bucks > myPlayer.bucks || bucks < 0 || isNaN(bucks)) {
                showNotification('Invalid number of bucks.');
                return;
            }
            document.getElementById('bucks-selection').style.display = 'none';
            socket.emit('playerAction', {
                action: 'submitMove',
                selectedBucks: bucks,
            });

            // Remove the outside click listener after submitting
            document.removeEventListener('click', outsideClickListener);
        }

        // Handle clicking outside the bucks selection to cancel
        function outsideClickListener(event) {
            const bucksSelection = document.getElementById('bucks-selection');
            if (!bucksSelection.contains(event.target)) {
                bucksSelection.style.display = 'none';
                myPlayer.selectedCard = null;
                myPlayer.selectedBucks = 0;
                socket.emit('playerAction', {
                    action: 'cancelSelection',
                });
                document.removeEventListener('click', outsideClickListener);
            }
        }

        // Update game information such as LP and Bucks
        function updateGameInfo() {
            document.getElementById('player1-lp').innerText = gameState.player1.lp;
            document.getElementById('player1-bucks').innerText = gameState.player1.bucks;
            document.getElementById('player2-lp').innerText = gameState.player2.lp;
            document.getElementById('player2-bucks').innerText = gameState.player2.bucks;
        }

        // Display a temporary turn indicator message
        function displayTurnIndicator(text) {
            const indicator = document.createElement('div');
            indicator.className = 'turn-indicator';
            indicator.innerText = text;
            document.body.appendChild(indicator);
            setTimeout(() => {
                document.body.removeChild(indicator);
            }, 2000);
        }

        // Handle and display the result of a battle
        function handleBattleResult(battleResult) {
            const attackerPlayer = battleResult.attackerId === myPlayer.id ? myPlayer : opponentPlayer;
            const defenderPlayer = battleResult.attackerId === myPlayer.id ? opponentPlayer : myPlayer;

            const attackerCardDiv = document.querySelector(`#player${attackerPlayer === gameState.player1 ? '1' : '2'}-cards .card[data-index="${battleResult.attackerCardIndex}"]`);
            const defenderCardDiv = document.querySelector(`#player${defenderPlayer === gameState.player1 ? '1' : '2'}-cards .card[data-index="${battleResult.defenderCardIndex}"]`);

            // Display battle result message
            const battleResultDiv = document.getElementById('battle-result');
            if (battleResult.winner === 'attacker') {
                battleResultDiv.innerText = `${attackerPlayer.name} Wins!`;
            } else if (battleResult.winner === 'defender') {
                battleResultDiv.innerText = `${defenderPlayer.name} Wins!`;
            } else {
                battleResultDiv.innerText = `It's a Tie!`;
            }

            // Log the battle result on the client side
            console.log('Battle Result:', battleResult);

            // Clear the battle result message after animation
            setTimeout(() => {
                battleResultDiv.innerText = '';
            }, 2000);
        }

        // Determine the winner based on remaining LP and Bucks
        function determineWinner() {
            if (myPlayer.lp > opponentPlayer.lp) {
                return myPlayer;
            } else if (opponentPlayer.lp > myPlayer.lp) {
                return opponentPlayer;
            } else {
                // If tied, decide based on bucks or declare Player 1 as winner
                if (myPlayer.bucks > opponentPlayer.bucks) {
                    return myPlayer;
                } else if (opponentPlayer.bucks > myPlayer.bucks) {
                    return opponentPlayer;
                } else {
                    // For simplicity, declare Player 1 as winner in case of a tie
                    return gameState.player1;
                }
            }
        }

        // Display the game over screen
        function displayGameOver(winner) {
            const winnerArea = winner === myPlayer ? document.getElementById('my-player-area') : document.getElementById('opponent-player-area');
            winnerArea.classList.add('game-over-winner');

            // Show a notification for game over
            showNotification(`Game Over! ${winner.name} Wins!`);
        }

        // Notification functions
        function showNotification(message) {
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notification-message');
            notificationMessage.innerText = message;
            notification.style.display = 'flex';
        }

        function closeNotification() {
            const notification = document.getElementById('notification');
            notification.style.display = 'none';
        }

    </script>
</body>
</html>
